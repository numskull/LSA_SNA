library(devtools)
install.packages("devtools")
devtools::install_github("michaelgavin/tei2r")
devtools::install_github("michaelgavin/empson")
install.packages("gtable")
devtools::install_github("michaelgavin/empson")
install.packages("scales")
library(empson)
devtools::install_github("michaelgavin/empson")
install.packages("lazyeval")
devtools::install_github("michaelgavin/empson")
install.packages("tibble")
install.packages("tibble")
devtools::install_github("michaelgavin/empson")
library(empson)
data(eebo)
similarity(eebo, "author")
load("C:/Users/travis/Dropbox/Grad School/896/10_22.RData")
library(igraph)
g = graph.adjacency(dirA %*% t(dirA), mode="undirected")
plot(g)
c = graph.adjacency(cocitation(dirA), mode="undirected", weighted = T)
plot(c)
plot(g)
plot(c)
plot(g)
cocitation = function(mat) {
newMat = mat
for(i in 1:length(mat[1,])) {
for(j in 1:length(mat[,1])) {
aik = sum(mat[i,])
akj = sum(t(mat)[,j])
newMat[i,j] = aik %*% akj
}
}
return(newMat)
}
cocitation(dirA)
g
c
d = graph.adjacency(cocitation(dirA), mode="undirected", weighted = T)
plot(d)
cocitation = function(mat) {
newMat = mat
for(i in 1:length(mat[1,])) {
for(j in 1:length(mat[,1])) {
if(i != j) {
aik = sum(mat[i,])
akj = sum(t(mat)[,j])
newMat[i,j] = aik %*% akj
}
}
}
return(newMat)
}
d = graph.adjacency(cocitation(dirA), mode="undirected", weighted = T)
plot(d)
plot(d)
E(g)
View(E(g))
E(d)
E(d)#weight
E(d)$weight
plot(d, edge.width=E(d)$weight)
cocitation(dirA)
dirA %*% t(dirA)
g = graph.adjacency(dirA)
plot(g)
plot(d, edge.width=E(d)$weight)
plot(d, edge.width=E(d)$weight)
cocitation = function(mat) { # Formula 6.7 in Newman
newMat = mat
for(i in 1:length(mat[1,])) {
for(j in 1:length(mat[,1])) {
for(k in 1:length(mat[1,])) {
if(i != j) {
aik = aik + mat[i,k]
akj = akj + t(mat)[k,j]
}
newMat[i,j] = aik %*% akj
}
}
}
return(newMat)
}
cocitation(dirA)
cocitation = function(mat) { # Formula 6.7 in Newman
newMat = mat
for(i in 1:length(mat[1,])) {
for(j in 1:length(mat[,1])) {
aik = 0
akj = 0
for(k in 1:length(mat[1,])) {
if(i != j) {
aik = aik + mat[i,k]
akj = akj + t(mat)[k,j]
}
newMat[i,j] = aik %*% akj
}
}
}
return(newMat)
}
cocitation(dirA)
d
d = graph.adjacency(cocitation(dirA), mode="undirected", weighted = T)
plot(d, edge.width=E(d)$weight)
E(d)$weight
B = c(1,0,0,1,0,1,1,1,1,0,0,1,1,0,1,0,0,1,1,1)
1 1 2 1 2 1 2 1 2 2 1 2 2 4 2
B = matrix(B, 4, 5)
B
B = c(1,0,0,1,0,1,1,1,1,0,0,1,1,0,1,0,0,1,1,1)
B = matrix(B, 5, 4)
B
B = c(1,0,0,1,0,1,1,1,1,0,0,1,1,0,1,0,0,1,1,1)
B = matrix(B, 4, 5)
B
t(B)
B = c(1,0,0,1,0,1,1,1,1,0,0,1,1,0,1,0,0,1,1,1)
B = matrix(B, byrow = T, 4,5)
B
g = graph.adjacency(B, mode='undirected')
g = graph.incidence(B, mode='undirected')
g = graph.incidence(B)
plot(g)
plot(g)
t(B) %*% B
diag(t(B) %*% B) = 0
test = t(B) %*% B
diag(test) = 0
test
testG = graph.adjacency(test, mode='undirected')
plot(testG)
testG = graph.adjacency(test, mode='undirected', weighted = T)
plot(testG, edge.width=E(testG)$weight)
test
t(B)
B
colnames(B) = c(1,2,3,4,5)
rownames(B) = c("A", "B", "C", "D")
B
t(B)
test = t(B) %*% B
test
test = B %*% t(B)
test
P' =
s
''
degree = function(mat, index) {
return(sum(mat[index,]))
}
degree(B, 2)
B
B['B',]
degree(mat, 'B')
degree(B, 'B')
Pp['B','B']
Pp = B %*% t(B) # Project to an adjacency matrix.
Pp # The diagonals here represent the number of members of each group.
Pp['B','B']
sumB
sum(B)
m2 = 0
for(i in 1:length(B[1,])) {
m2 = m2 + degree(B, i)
}
m2 = 0
for(i in 1:length(B[1,])) {
m2 = m2 + degree(B, i)
}
length(B1,)
length(B[1,])
degree(B, 5)
B
m2 = 0
for(i in 1:length(B[,1])) {
m2 = m2 + degree(B, i)
}
m2
dirA
numPaths = function(A, len){ # 6.32
N = 0
for(i in 1:length(A[,1])) {
for(j in 1:length(A[1,])) {
N = N + (A^3)[i,j]
}
}
return(N)
}
N = numpaths(A, 2)
N = numPaths(A, 2)
N
numPaths = function(A, len){ # 6.32
N = 0
for(i in 1:length(A[,1])) {
for(j in 1:length(A[1,])) {
if((A^3)[i,j] >= 1){
N = N+1
}
}
}
return(N)
}
N = numPaths(A, 2)
numPaths = function(A, len){ # 6.32
N = 0
for(i in 1:length(A[,1])) {
for(j in 1:length(A[1,])) {
if((A^len)[i,j] >= 1){
N = N+1
}
}
}
return(N)
}
N = numPaths(A, 2)
N
N = numPaths(A, 3)
N
N = numPaths(A, 1)
N
A^3
A
A %*% A
install(expm)
install.packages("expm")
library(expm)
A %^% 2
A %*% A
numPaths = function(A, len){ # 6.32
N = 0
for(i in 1:length(A[,1])) {
for(j in 1:length(A[1,])) {
if((A%^%len)[i,j] == len){
N = N+1
}
}
}
return(N)
}
N = numPaths(A, 2)
N
A
N = numPaths(A, 3)
N
N = numPaths(A, 4)
N
N = numPaths(A, 6)
N
N = numPaths(A, 1)
N
numLoops = functon(A, len){
return(sum(diag(A %^% len)))
}
numLoops = function(A, len){
return(sum(diag(A %^% len)))
}
L = numLoops(A, 2)
L
diag(A %^% len)
diag(A %^% 2)
diag(A)
A
A %^% 2
sum(diag(A %^% 2))
sum(diag(A %^% 3))
sum(diag(A %^% 4))
sum(diag(A %^% 5))
sum(diag(A %^% 6))
eigen(A)
geodesic = function(A, i, j) {
done = FALSE
count = 1
while (done == false) {
aij = A %^% count
if(aij[i,j] > 0) {
return(count)
}
count++1
}
}
geodesic(A, 2, 4)
geodesic = function(A, i, j) {
done = FALSE
count = 1
while (done == F) {
aij = A %^% count
if(aij[i,j] > 0) {
return(count)
}
count++1
}
}
geodesic(A, 2, 4)
geodesic(A, 2, 5)
geodesic = function(A, i, j) {
done = FALSE
count = 1
while (done == F) {
aij = A %^% count
if(aij[i,j] > 0) {
return(count)
}
if(count >= 20) { # Assume no path if greater than 20
done = TRUE
}
count++1
}
}
geodesic(A, 2, 5)
geodesic = function(A, i, j) {
done = FALSE
count = 1
while (done == F) {
echo(count)
aij = A %^% count
if(aij[i,j] > 0) {
return(count)
}
if(count >= 20) { # Assume no path if greater than 20
done = TRUE
}
count++1
}
}
geodesic(A, 2, 5)
geodesic = function(A, i, j) {
done = FALSE
count = 1
while (done == F) {
count
aij = A %^% count
if(aij[i,j] > 0) {
return(count)
}
if(count >= 20) { # Assume no path if greater than 20
done = TRUE
}
count++1
}
}
geodesic(A, 2, 5)
geodesic = function(A, i, j) {
done = FALSE
count = 1
while (done == F) {
print(count)
aij = A %^% count
if(aij[i,j] > 0) {
return(count)
}
if(count >= 20) { # Assume no path if greater than 20
done = TRUE
}
count++1
}
}
geodesic(A, 2, 5)
geodesic = function(A, i, j) {
done = FALSE
count = 1
while (done == F) {
print(count)
aij = A %^% count
if(aij[i,j] > 0) {
return(count)
}
if(count >= 20) { # Assume no path if greater than 20
done = TRUE
}
count = count + 1
}
}
geodesic(A, 2, 4)
geodesic(A, 2, 5)
geodesic(A, 2, 2)
geodesic(A, 2, 1)
geodesic(A, 2, 3)
save.image("C:/Users/travis/Dropbox/Grad School/896/10_22.RData")
ppmi = function(df) { # Turney and Pantel, p. 157
newDf = df
total = sum(df)
rows = sum(rowSums(df))
cols = sum(colSums(df))
#browser()
bottom = total
for(i in 1:length(df[,1])){
sumR = sum(df[i,])
for(j in 1:length(df[1,])){
colSum = sum(df[,j])
pij = (df[i,j] / total)
pi = sumR / total
pj = colSum / total
pmi = log(pij/(pi * pj))
#browser()
if (pmi < 0){
pmi = 0
}
newDf[i,j] = pmi
}
}
return(newDf)
}
ppmi = function(df) { # Turney and Pantel, p. 157
newDf = df
total = sum(df)
bottom = total
for(i in 1:length(df[,1])){
sumR = sum(df[i,])
for(j in 1:length(df[1,])){
colSum = sum(df[,j])
pij = (df[i,j] / total)
pi = sumR / total
pj = colSum / total
pmi = log(pij/(pi * pj))
#browser()
if (pmi < 0){
pmi = 0
}
newDf[i,j] = pmi
}
}
return(newDf)
}
df = as.matrix(read.csv('shakespeare.csv', row.names=1))
setwd("C:\Users\travis\Dropbox\Grad School\896")
setwd("C:/Users/travis/Dropbox/Grad School/896")
df = as.matrix(read.csv('shakespeare.csv', row.names=1))
s = diag(svd(df, nv=5, nu=5)$d)
v = svd(df, nv=5, nu=5)$v
u = svd(df, nv=5, nu=5)$u
shape(u)
u.shape
dim(u)
dim(s)
u %*% s
s = svd(df, nv=5, nu=5)$d
dim(s)
s
class(s)
s = diag(s)
dim(s)
s = svd(df, nv=5, nu=5)$d
u %*% s
u * s
s = diag(s)
u * s
class(u)
dim(u)
dim(v)
dim(s)
df = ppmi(as.matrix(read.csv('shakespeare.csv', row.names=1)))
s = diag(s)
s = svd(df, nv=5, nu=5)$d
s = diag(s)
v = svd(df, nv=5, nu=5)$v
u = svd(df, nv=5, nu=5)$u
dim(s)
dim(u)
dim(v)
u %*% s
View(u)
dim(v)
s = svd(df, nv=5, nu=5)$d
u * s
s = svd(df, nv=5, nu=5)
v = s$v
u = s$u
s = diag(s)$d
s = diag(s$d)
dim(s)
dim(u)
dim(v)
u *%* v
u %*% v
u %*% t(v)
save.image("C:/Users/travis/Dropbox/Grad School/896/10_22.RData")
