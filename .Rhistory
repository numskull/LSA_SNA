imp = imps[[i]]
if (length(imp) == 0) {next()}
# Don't select initials
names = which(nchar(imp) > 1)
if (length(names) == 0) {next()}
# The 'names' object is an integer vector that points to words longer than 1 character in 'imp'
for (j in 1:length(names)) {
# If names[j] is the first word in 'imp', skip it. (B/c it's a first name.)
if (names[j] == 1) {next()}
# First, search for matching last name
possibles = grep(toupper(imp[names[j]]),toupper(df.r$lName))
#     if (length(possibles) == 1) {
#       # If you find only one, do nothing and move on.
#     }
#
# If you find none, broaden to "agrep" search
#browser()
if (length(possibles) == 0) {
possibles = agrep(toupper(imp[names[j]]),toupper(df.r$lName))
# But restrict results to possibles that share the same first letter.
possibles = possibles[substring(df.r$lName[possibles],1,1) == substring(imp[names[j]],1,1)]
}
# If you find none at this point, you don't have a name. Move on.
if (length(possibles) == 0) {
next()
}
# If you find exactly one, grab it and move on
#     if (length(possibles) == 1) {
#       matches = c(matches,possibles)
#       next()
#     }
# If you have more than one possibility, time to search by first name (the first word in 'imps' doesn't run this test)
if (names[j] > 1 & length(possibles) > 0) {
prior = imp[names[j]-1]
firstInitial = substring(prior,1,1)
possiblesInitials = substring(df.r$fName[possibles],1,1)
firstNamePass = grep(firstInitial,possiblesInitials)
}
# If you find exactly one first name match among the possibles, grab it and move on
if (length(firstNamePass) == 1) {
matches = c(matches,possibles[firstNamePass])
next()
}
if (length(firstNamePass) > 1) { # If you find more than one first name with the same first initials
possibles = possibles[firstNamePass] # Restrict possibles down.
if (nchar(prior) == 1) { # Are you just working from an initial? If so, just grab the one with the closest date.
closestByDate = which(dates[i] - df.r$date[possibles] == min(dates[i] - df.r$date[possibles]))
matches = c(matches,possibles[closestByDate])
next()
}
if (nchar(prior) > 1) { # If it's a whole name, find the closest one by Levenstein distance
closestByName = which(adist(prior,df.r$fName[possibles]) == min(adist(prior,df.r$fName[possibles]),na.rm=T))
if (length(closestByName) == 1) {
matches = c(matches,possibles[closestByName])
next()
} else { # If more than one name has the same edit distance, grab the one with the closest date
possibles = possibles[closestByName]
closestByNamesAndDate = which(dates[i] - df.r$date[possibles] == min(dates[i] - df.r$date[possibles]))
matches = c(matches,possibles[closestByNamesAndDate])
if (length(closestByNamesAndDate) > 1) multiples = c(multiples,i)
}
}
}
}
matchesList[[i]] = row.names(df.r)[matches]
}
length(matchesList)
length(estc$imprint)
View(matchesList)
matchesList = list(rep(c()), length(estc$imprint))
multiples = c()
length(matchesList)
matchesList = list(rep(c(), length(estc$imprint)))
length(matchesList)
View(matchesList)
matchesList = list(rep(c(""), length(estc$imprint)))
length(matchesList)
matchesList = rep(list(c()), length(estc$imprint))
length(matchesList)
View(matchesList)
multiples = c()
for (i in 1:length(imps)) {
print(i)
matches = c()
# Limit BBTI to plausible date range
rightTimes = which(df$date < dates[i] + 3 & df$date > dates[i] - 50)
df.r = df[rightTimes,]
# Select the imprint
imp = imps[[i]]
if (length(imp) == 0) {next()}
# Don't select initials
names = which(nchar(imp) > 1)
if (length(names) == 0) {next()}
# The 'names' object is an integer vector that points to words longer than 1 character in 'imp'
for (j in 1:length(names)) {
# If names[j] is the first word in 'imp', skip it. (B/c it's a first name.)
if (names[j] == 1) {next()}
# First, search for matching last name
possibles = grep(toupper(imp[names[j]]),toupper(df.r$lName))
#     if (length(possibles) == 1) {
#       # If you find only one, do nothing and move on.
#     }
#
# If you find none, broaden to "agrep" search
#browser()
if (length(possibles) == 0) {
possibles = agrep(toupper(imp[names[j]]),toupper(df.r$lName))
# But restrict results to possibles that share the same first letter.
possibles = possibles[substring(df.r$lName[possibles],1,1) == substring(imp[names[j]],1,1)]
}
# If you find none at this point, you don't have a name. Move on.
if (length(possibles) == 0) {
next()
}
# If you find exactly one, grab it and move on
#     if (length(possibles) == 1) {
#       matches = c(matches,possibles)
#       next()
#     }
# If you have more than one possibility, time to search by first name (the first word in 'imps' doesn't run this test)
if (names[j] > 1 & length(possibles) > 0) {
prior = imp[names[j]-1]
firstInitial = substring(prior,1,1)
possiblesInitials = substring(df.r$fName[possibles],1,1)
firstNamePass = grep(firstInitial,possiblesInitials)
}
# If you find exactly one first name match among the possibles, grab it and move on
if (length(firstNamePass) == 1) {
matches = c(matches,possibles[firstNamePass])
next()
}
if (length(firstNamePass) > 1) { # If you find more than one first name with the same first initials
possibles = possibles[firstNamePass] # Restrict possibles down.
if (nchar(prior) == 1) { # Are you just working from an initial? If so, just grab the one with the closest date.
closestByDate = which(dates[i] - df.r$date[possibles] == min(dates[i] - df.r$date[possibles]))
matches = c(matches,possibles[closestByDate])
next()
}
if (nchar(prior) > 1) { # If it's a whole name, find the closest one by Levenstein distance
closestByName = which(adist(prior,df.r$fName[possibles]) == min(adist(prior,df.r$fName[possibles]),na.rm=T))
if (length(closestByName) == 1) {
matches = c(matches,possibles[closestByName])
next()
} else { # If more than one name has the same edit distance, grab the one with the closest date
possibles = possibles[closestByName]
closestByNamesAndDate = which(dates[i] - df.r$date[possibles] == min(dates[i] - df.r$date[possibles]))
matches = c(matches,possibles[closestByNamesAndDate])
if (length(closestByNamesAndDate) > 1) multiples = c(multiples,i)
}
}
}
}
matchesList[[i]] = row.names(df.r)[matches]
}
length(matchesList)
View(matchesList)
df[1117,]
save(matchesList,file="matches_3.RData")
names(imps)
names(imps) = estc$estc_cit_number
names(imps)
namesList = list()
for (i in 1:length(matchesList)) {
print(i)
peeps = matchesList[[i]]
names = c()
for (j in 1:length(peeps)) {
if (j > 0) {
row = which(rownames(df) == peeps[j])
#namej = paste(imprints[row,], collapse="; ")
namej = do.call(paste, c(as.list(df[row,]), sep="; "))
}
names = c(names,namej)
names = names[which(names != "character(0); character(0); numeric(0);")]
}
namesList[[i]] = names
}
view(namesList)
View(namesList)
estc$imprint[101]
estc$imprint[104]
names(namesList)[1:length(imps)] = imps[1:length(imps)]
View(namesList)
names(namesList)
names(imps)
names(namesList) = names(imps)
View(namesList)
names(namesList)
save(namesList,file="names.RData")
netCos = function(A, i,j){ # Using 7.48 because it accounts for weighted networks.
library(expm)
mat = A %^% 2
top = A[i,] %*% A[j,]
bottom = sqrt(mat[i,]) %*% sqrt(mat[j,])
dist = top / bottom
return(dist)
}
netCos(A)
netCos = function(A, i,j){ # Using 7.48 because it accounts for weighted networks.
library(expm)
mat = A %^% 2
top = A[i,] %*% A[j,]
bottom = sqrt(mat[i,]) %*% sqrt(mat[j,])
dist = top / bottom
return(dist)
}
netCos(A, 1,4)
netCos = function(A, i,j){ # Using 7.48 because it accounts for weighted networks.
library(expm)
mat = A %^% 2
top = A[i,] %*% A[j,]
bottom = sqrt(mat[i,]) %*% sqrt(mat[j,])
dist = top / bottom
return(dist)
}
netCos(A, 1,4)
pearson = function(A,i,j) {
cov = (Ai[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
bottom = sqrt((Ai[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 4)
pearson = function(A,i,j) {
cov = (Ai[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 4)
pearson = function(A,i,j) {
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 4)
pearson = function(A,i,j) {
n = nrow(A)
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 4)
pearson = function(A,i,j) {
n = nrow(A)
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 2)
pearson = function(A,i,j) {
n = nrow(A)
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 3)
pearson = function(A,i,j) {
n = nrow(A)
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 5)
pearson = function(A,i,j) {
n = nrow(A)
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 6)
pearson = function(A,i,j) {
n = nrow(A)
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
print(cov)
for(k in 1:ncol(A)) {
cov = cov + ((A[i,k] - (n^1 * A[i,])) %*% (A[j,k] - (n^1 * A[j,])))
}
print(cov)
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 3)
pearson = function(A,i,j) {
n = nrow(A)
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
print(cov)
for(k in 1:ncol(A)) {
cov = cov + ((A[i,k] - (n^1 * A[i,])) %*% (A[j,k] - (n^1 * A[j,])))
bottom = bottom + sqrt((A[i,k] - (n^1 * A[i,k]))^2) %*% sqrt((A[j,k] - (n^1 * A[j,k]))^2)
}
print(cov)
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 3)
pearson = function(A,i,j) {
n = nrow(A)
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
print(cov)
for(k in 1:ncol(A)) {
cov = cov + ((A[i,k] - (n^1 * A[i,])) %*% (A[j,k] - (n^1 * A[j,])))
bottom = bottom + sqrt((A[i,k] - (n^1 * A[i,k]))^2) %*% sqrt((A[j,k] - (n^1 * A[j,k]))^2)
}
print(cov)
#bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
r = cov / bottom
return(r)
}
pearson(A, 1, 3)
pearson = function(A,i,j) {
n = nrow(A)
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
print(cov)
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
print(bottom)
for(k in 1:ncol(A)) {
cov = cov + ((A[i,k] - (n^1 * A[i,])) %*% (A[j,k] - (n^1 * A[j,])))
bottom = bottom + sqrt((A[i,k] - (n^1 * A[i,k]))^2) %*% sqrt((A[j,k] - (n^1 * A[j,k]))^2)
}
print(cov)
print(bottom)
r = cov / bottom
return(r)
}
pearson(A, 1, 3)
pearson = function(A,i,j) {
n = nrow(A)
for(k in 1:ncol(A)) {
cov = cov + ((A[i,k] - (n^1 * A[i,])) %*% (A[j,k] - (n^1 * A[j,])))
bottom = bottom + sqrt((A[i,k] - (n^1 * A[i,k]))^2) %*% sqrt((A[j,k] - (n^1 * A[j,k]))^2)
}
print(cov)
print(bottom)
r = cov / bottom
return(r)
}
pearson(A, 1, 3)
pearson = function(A,i,j) {
n = nrow(A)
cov = 0
bottom = 0
for(k in 1:ncol(A)) {
cov = cov + ((A[i,k] - (n^1 * A[i,])) %*% (A[j,k] - (n^1 * A[j,])))
bottom = bottom + sqrt((A[i,k] - (n^1 * A[i,k]))^2) %*% sqrt((A[j,k] - (n^1 * A[j,k]))^2)
}
print(cov)
print(bottom)
r = cov / bottom
return(r)
}
pearson(A, 1, 3)
pearson = function(A,i,j) {
n = nrow(A)
cov = 0
bottom = 0
# for(k in 1:ncol(A)) {
#   cov = cov + ((A[i,k] - (n^1 * A[i,])) %*% (A[j,k] - (n^1 * A[j,])))
#   bottom = bottom + sqrt((A[i,k] - (n^1 * A[i,k]))^2) %*% sqrt((A[j,k] - (n^1 * A[j,k]))^2)
# }
cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
print(cov)
bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
print(bottom)
r = cov / bottom
return(r)
}
pearson(A, 1, 3)
pearson = function(A,i,j) {
n = nrow(A)
cov = 0
bottom = 0
for(k in 1:ncol(A)) {
cov = cov + ((A[i,k] - (n^1 * A[i,k])) %*% (A[j,k] - (n^1 * A[j,k])))
bottom = bottom + sqrt((A[i,k] - (n^1 * A[i,k]))^2) %*% sqrt((A[j,k] - (n^1 * A[j,k]))^2)
}
# cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
# print(cov)
# bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
# print(bottom)
r = cov / bottom
return(r)
}
pearson(A, 1, 3)
pearson = function(A,i,j) {
n = nrow(A)
cov = 0
bottom = 0
for(k in 1:ncol(A)) {
cov = cov + ((A[i,k] - (n^1 * A[i,k])) %*% (A[j,k] - (n^1 * A[j,k])))
bottom = bottom + sqrt((A[i,k] - (n^1 * A[i,k]))^2) %*% sqrt((A[j,k] - (n^1 * A[j,k]))^2)
}
# cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
# print(cov)
# bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
# print(bottom)
r = cov / bottom
return(r)
}
pearson(A, 1, 5)
pearson = function(A,i,j) {
n = nrow(A)
cov = 0
bottom = 0
for(k in 1:ncol(A)) {
cov = cov + ((A[i,k] - (n^1 * A[i,k])) %*% (A[j,k] - (n^1 * A[j,k])))
bottom = bottom + sqrt((A[i,k] - (n^1 * A[i,k]))^2) %*% sqrt((A[j,k] - (n^1 * A[j,k]))^2)
}
# cov = (A[i,] - (n^1 * A[i,])) %*% (A[j,] - (n^1 * A[j,]))
# print(cov)
# bottom = sqrt((A[i,] - (n^1 * A[i,]))^2) %*% sqrt((A[j,] - (n^1 * A[j,]))^2)
# print(bottom)
r = cov / bottom
return(r)
}
pearson(A, 1, 3)
regEq = function(A, i=0, j=0) {
k = max(as.numeric(eigen(A)$values))  # Directed graphs give complex number values.
alpha = 1/k - .05 # Slightly less than 1/max eigenvalue
sim = (diag(1, nrow(A), ncol(A)) - alpha * A)^-1
if(i != 0 && j != 0){
return(sim[i,j])
}
return(sim)
}
reqEq(A)
regEq = function(A, i=0, j=0) {
k = max(as.numeric(eigen(A)$values))  # Directed graphs give complex number values.
alpha = 1/k - .05 # Slightly less than 1/max eigenvalue
sim = (diag(1, nrow(A), ncol(A)) - alpha * A)^-1
if(i != 0 && j != 0){
return(sim[i,j])
}
return(sim)
}
regEq(A)
regEq = function(A, i=0, j=0) {
k = max(as.numeric(eigen(A)$values))  # Directed graphs give complex number values.
alpha = 1/k - .05 # Slightly less than 1/max eigenvalue
#sim = (diag(1, nrow(A), ncol(A)) - alpha * A)^-1
D = diag(degreeCent(A))
sim = (D - (alpha * A))^-1 %*% D
if(i != 0 && j != 0){
return(sim[i,j])
}
return(sim)
}
regEq(A)
regEq = function(A, i=0, j=0) {
k = max(as.numeric(eigen(A)$values))  # Directed graphs give complex number values.
alpha = 1/k - .05 # Slightly less than 1/max eigenvalue
#sim = (diag(1, nrow(A), ncol(A)) - alpha * A)^-1
D = diag(degreeCent(A))
sim = (D - (alpha * A))^-1 * D
if(i != 0 && j != 0){
return(sim[i,j])
}
return(sim)
}
regEq(A)
regEq = function(A, i=0, j=0) {
k = max(as.numeric(eigen(A)$values))  # Directed graphs give complex number values.
alpha = 1/k - .05 # Slightly less than 1/max eigenvalue
#sim = (diag(1, nrow(A), ncol(A)) - alpha * A)^-1
D = diag(degreeCent(A))
print(D)
sim = (D - (alpha * A))^-1 *% D
regEq = function(A, i=0, j=0) {
k = max(as.numeric(eigen(A)$values))  # Directed graphs give complex number values.
alpha = 1/k - .05 # Slightly less than 1/max eigenvalue
#sim = (diag(1, nrow(A), ncol(A)) - alpha * A)^-1
D = diag(degreeCent(A))
print(D)
sim = (D - (alpha * A))^-1 %*% D
if(i != 0 && j != 0){
return(sim[i,j])
}
return(sim)
}
regEq(A)
eigen(A)
D = diag(degreeCent(A))
k = max(as.numeric(eigen(A)$values))  # Directed graphs give complex number values.
alpha = 1/k - .05 # Slightly less than 1/max eigenvalue
(D - (alpha * A))^-1
(D - (alpha %*% A))^-1
(D - (alpha * A))^-1
(D - (alpha * A))
(D - (alpha * A))^-1 %*% D
(D - (alpha * A))^-1 * D
regEq = function(A, i=0, j=0) {
k = max(as.numeric(eigen(A)$values))  # Directed graphs give complex number values.
alpha = 1/k - .05 # Slightly less than 1/max eigenvalue
I = diag(1, nrow(A), ncol(A))
sim = (I - alpha * A)^-1
# D = diag(degreeCent(A))
# print(D)
# sim = (D - (alpha * A))^-1 %*% D
if(i != 0 && j != 0){
return(sim[i,j])
}
return(sim)
}
regEq(A)
