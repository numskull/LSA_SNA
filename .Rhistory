bets = c()
bet = 0
for(i in 1:nrow(A)){
for(j in 1:ncol(A)) {
geos[i,j] = geodesic(A,i,j)
}
}
for(s in 1:nrow(A)) {
for(t in 1:ncol(A)) {
bet = 0
for(i in 1:nrow(A)) {
if(geos[s,i] > 0 && geos[t,i] > 0){
bet = bet + 1
}
}
}
bets[s] = bet
}
return(bets)
}
betweenness(A)
igraph::betweenness(A)
igraph::betweenness(g)
betweenness = function(A) {
geos = A
bets = c()
bet = 0
for(i in 1:nrow(A)){
for(j in 1:ncol(A)) {
geos[i,j] = geodesic(A,i,j)
}
}
for(s in 1:nrow(A)) {
for(t in 1:ncol(A)) {
bet = 0
for(i in 1:nrow(A)) {
if(geos[s,i] > 0 && geos[t,i] > 0){
bet = bet + 1
}
}
bet = bet / geos[s,t]
}
bets[s] = bet
}
return(bets)
}
betweenness(A)
igraph::betweenness(g)
betweenness = function(A) {
geos = A
bets = c()
bet = c()
for(i in 1:nrow(A)){
for(j in 1:ncol(A)) {
geos[i,j] = geodesic(A,i,j)
}
}
for(s in 1:nrow(A)) {
for(t in 1:ncol(A)) {
bet = 0
for(i in 1:nrow(A)) {
if(geos[s,i] > 0 && geos[t,i] > 0){
bet = bet + 1
}
}
bet[t] = bet / geos[s,t]
}
bets[s] = (1/(nrow(A))^2) * sum(bet)
}
return(bets)
}
betweenness(A)
betweenness = function(A) {
geos = A
bets = c()
bet = c()
for(i in 1:nrow(A)){
for(j in 1:ncol(A)) {
geos[i,j] = geodesic(A,i,j)
}
}
for(s in 1:nrow(A)) {
for(t in 1:ncol(A)) {
bet[t] = 0
for(i in 1:nrow(A)) {
if(geos[s,i] > 0 && geos[t,i] > 0){
bet[t] = bet[t] + 1
}
}
bet[t] = bet[t] / geos[s,t]
}
bets[s] = (1/(nrow(A))^2) * sum(bet)
}
return(bets)
}
betweenness(A)
betweenness = function(A) {
geos = A
bets = c()
bet = c()
for(i in 1:nrow(A)){
for(j in 1:ncol(A)) {
geos[i,j] = geodesic(A,i,j)
}
}
for(s in 1:nrow(A)) {
for(t in 1:ncol(A)) {
bet[t] = 0
for(i in 1:nrow(A)) {
if(geos[s,i] > 0 && geos[t,i] > 0){
bet[t] = bet[t] + 1
}
}
bet[t] = bet[t] / geos[s,t]
}
bets[s] = sum(bet)
}
return(bets)
}
betweenness(A)
igraph::betweenness(g, normalized = T)
betweenness = function(A) {
geos = A
bets = c()
bet = c()
for(i in 1:nrow(A)){
for(j in 1:ncol(A)) {
geos[i,j] = geodesic(A,i,j)
}
}
for(s in 1:nrow(A)) {
for(t in 1:ncol(A)) {
bet[t] = 0
for(i in 1:nrow(A)) {
if(geos[s,i] > 0 && geos[t,i] > 0){
bet[t] = bet[t] + 1
}
}
bet[t] = bet[t]
}
bets[s] = sum(bet)/ geos[s,t]
}
return(bets)
}
betweenness(A)
save.image("C:/Users/travis/Dropbox/Grad School/896/11_5.RData")
cluster = function(A){
top = 0
bottom = 0
for(i in 1:nrow(A)){
for(j in 1:ncol(A)){
for(k in 1:ncol(A)){
if(A[i,k] > 0 && A[j,k] > 0){
top = top + 1
}
}
if(A[i,j] > 0) {
bottom = bottom + 1
}
}
}
C = top / bottom
return(C)
}
cluster(A)
cluster = function(A){
top = 0
bottom = numPaths(A, 2)
for(i in 1:nrow(A)){
for(j in 1:ncol(A)){
for(k in 1:ncol(A)){
if(A[i,k] > 0 && A[j,k] > 0){
top = top + 1
}
}
}
}
C = top / bottom
return(C)
}
cluster(A)
library(expm)
cluster(A)
numpaths(A,2)
numPaths(A,2)
cluster = function(A){
top = 0
bottom = numPaths(A, 2)
for(i in 1:nrow(A)){
for(j in 1:ncol(A)){
for(k in 1:ncol(A)){
if(i !=j && j != k && i != k){
if(A[i,k] > 0 && A[j,k] > 0){
top = top + 1
}
}
}
}
}
C = top / bottom
return(C)
}
cluster(A)
cluster = function(A){
top = 0
bottom = numPaths(A, 2)
for(i in 1:nrow(A)){
for(j in 1:ncol(A)){
for(k in 1:ncol(A)){
if(i !=j && j != k && i != k){
if(A[i,k] > 0 && A[j,k] > 0 && A[i,j] > 0){
top = top + 1
}
}
}
}
}
C = top / bottom
return(C)
}
cluster(A)
install.packages("foreach")
library(foreach)
foreach(neighbors){}
localCluster = function(A, i){
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)){
if(A[neighbors[j],neighors[j+1]] > 0) {
top = top + 1
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
localCluster = function(A, i){
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)){
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
which(A[2,] > 0)
localCluster = function(A, i){
library(foreach)
neighbors = which(A[i,] > 0)
top = 0
foreach(neighbors) %do% {
if(neighbors > 0) {
top = top + 1
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
neighbors = which(A[i,] > 0)
neighbors
A[neighbors[1],]
A[neighbors[2],]
A[neighbors[3],]
neighbors[1]
neighbors[2]
neighbors[3]
neighbors[4]
neighbors[5]
neighbors
neighbors = which(A[2,] > 0)
neighbors
neighbors[1]
neighbors[2]
A[neighbors[1]]
A[neighbors[1],]
A['Bill',]
A
A[neighbors[1],neighbors[2]]
A[neighbors[1],neighbors[3]]
A[neighbors[1],neighbors[4]]
neighbors
localCluster = function(A, i){
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)){
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
j
i = 2
neighbors = which(A[i,] > 0)
length(neighbors)
j
localCluster = function(A, i){
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)) {
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
localCluster = function(A, i){
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)) {
browser()
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
j
neighbors
A[neighbors[j],neighbors[j+1]]
localCluster = function(A, i){
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)-1) {
browser()
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
localCluster = function(A, i){
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)) {
browser()
if(j< length(neighbors)){
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
} else {
if(A[neighbors[i],neighbors[j]] > 0) {
top = top + 1
}
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
localCluster = function(A, i){
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)) {
if(j< length(neighbors)){
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
} else {
if(A[neighbors[i],neighbors[j]] > 0) {
top = top + 1
}
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
localCluster = function(A, i){  #7.42
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)) {
if(j< length(neighbors)){
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
localCluster = function(A, i){  #7.42
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)) {
if(j< length(neighbors)){
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 3)
localCluster = function(A, i){  #7.42
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)) {
if(j< length(neighbors)){
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 1)
localCluster = function(A, i){  #7.42
neighbors = which(A[i,] > 0)
top = 0
for(j in 1:length(neighbors)) {
if(j< length(neighbors)){
if(A[neighbors[j],neighbors[j+1]] > 0) {
top = top + 1
}
}
}
k = degree(A,i)
C = top/((1/2*k)*(k-1))
return(C)
}
localCluster(A, 2)
# Using local clustering to get centralities of vertices.
LC = c()
for(i in 1:nrow(A)){
LC[i] = localCluster(A, i)
}
row.names(LC) = row.names(A)
LC = c()
for(i in 1:nrow(A)){
LC[i] = localCluster(A, i)
}
LC
nrow(A)
length(LC)
A[6,]
# Using local clustering to get centralities of vertices.
LC = c()
for(i in 1:nrow(A)){
LC[i] = localCluster(A, i)
if(LC[i] = NaN){
# Using local clustering to get centralities of vertices.
LC = c()
for(i in 1:nrow(A)){
LC[i] = localCluster(A, i)
if(LC[i] == NaN){
LC[i] = 0
}
}
# Using local clustering to get centralities of vertices.
LC = c()
for(i in 1:nrow(A)){
LC[i] = localCluster(A, i)
if(is.nan(LC[i])) {
LC[i] = 0
}
}
names(LC) = row.names(A)
LC
igraph::betweenness(g, normalized = T)
plot(g)
library(igraph)
g = graph.adjacency(A, mode='undirected')
igraph::betweenness(g)
igraph::betweenness(g, normalized=T)
plot(g)
A['sally',]
A['Sally',]
i = 4
A[i,]
A
neighbors = which(A[i,] > 0)
neighbors
A[i.]
A[i,]
A[i, neighbors[1]]
A[neighbors[1], neighbors[2]]
localCluster(4)
localCluster(A4)
localCluster(A,4)
degree(A,4)
igraph::cluster.distribution(A)
igraph::cluster.distribution(g)
igraph::cluster.distribution(g, cumulative = T)
save.image("C:/Users/travis/Dropbox/Grad School/896/11_5.RData")
